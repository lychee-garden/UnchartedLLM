<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>UnchartedLLM Chatbot</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            overflow: hidden;
        }

        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
        }

        .header p {
            font-size: 1.1em;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            padding: 30px;
        }

        .left-panel, .right-panel {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .card {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 20px;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        }

        .card h2 {
            color: #667eea;
            margin-bottom: 15px;
            font-size: 1.5em;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }

        .input-group {
            margin-bottom: 15px;
        }

        .input-group label {
            display: block;
            margin-bottom: 5px;
            color: #333;
            font-weight: 600;
        }

        .input-group input, .input-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #ddd;
            border-radius: 8px;
            font-size: 1em;
            transition: border-color 0.3s;
        }

        .input-group input:focus, .input-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }

        .input-group textarea {
            resize: vertical;
            min-height: 100px;
            font-family: inherit;
        }

        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }

        button {
            flex: 1;
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1em;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 12px rgba(102, 126, 234, 0.4);
        }

        .btn-primary:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .btn-danger {
            background: #dc3545;
            color: white;
        }

        .btn-danger:hover {
            background: #c82333;
        }

        .output-box {
            background: white;
            border: 2px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            min-height: 200px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 0.95em;
            line-height: 1.6;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            margin-top: 15px;
        }

        .stat-card {
            background: white;
            border-radius: 8px;
            padding: 15px;
            text-align: center;
            border: 2px solid #667eea;
        }

        .stat-card .label {
            color: #666;
            font-size: 0.9em;
            margin-bottom: 5px;
        }

        .stat-card .value {
            color: #667eea;
            font-size: 1.8em;
            font-weight: bold;
        }

        .control-panel {
            background: #fff3cd;
            border: 2px solid #ffc107;
            border-radius: 8px;
            padding: 15px;
        }

        .control-panel h3 {
            color: #856404;
            margin-bottom: 10px;
        }

        .chart-container {
            position: relative;
            width: 100%;
            margin-top: 15px;
        }

        .chart-container-square {
            position: relative;
            width: 100%;
            padding-bottom: 100%; /* 1:1 aspect ratio */
            margin-top: 15px;
        }

        .chart-container-square canvas {
            position: absolute;
            top: 0;
            left: 0;
            width: 100% !important;
            height: 100% !important;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-connected {
            background: #28a745;
            box-shadow: 0 0 8px #28a745;
        }

        .status-disconnected {
            background: #dc3545;
        }

        .status-generating {
            background: #ffc107;
            animation: pulse 1s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .connection-status {
            display: flex;
            align-items: center;
            justify-content: center;
            padding: 10px;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 15px;
        }

        .loading {
            display: inline-block;
            width: 20px;
            height: 20px;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #667eea;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-left: 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .charts-section {
            grid-column: 1 / -1;
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            .charts-section {
                grid-template-columns: 1fr;
            }
        }

        .token-highlight {
            background: #ffffcc;
            padding: 2px 4px;
            border-radius: 3px;
            animation: highlight 0.5s;
        }

        @keyframes highlight {
            from { background: #ffff00; }
            to { background: #ffffcc; }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸš€ UnchartedLLM Chatbot</h1>
            <p>å¯æ§é•¿åº¦æ–‡æœ¬ç”Ÿæˆ - å®æ—¶äº¤äº’å¼ç•Œé¢</p>
        </div>

        <div class="main-content">
            <!-- å·¦ä¾§é¢æ¿ -->
            <div class="left-panel">
                <!-- è¿æ¥çŠ¶æ€ -->
                <div class="card">
                    <div class="connection-status">
                        <span class="status-indicator" id="statusIndicator"></span>
                        <span id="statusText">æœªè¿æ¥</span>
                        <span id="loadingSpinner" class="loading" style="display: none;"></span>
                    </div>
                </div>

                <!-- è¾“å…¥é…ç½® -->
                <div class="card">
                    <h2>ğŸ“ è¾“å…¥é…ç½®</h2>
                    <div class="input-group">
                        <label for="promptInput">Prompt (æç¤ºè¯):</label>
                        <textarea id="promptInput" placeholder="è¯·è¾“å…¥æç¤ºè¯...">Once upon a time</textarea>
                    </div>
                    <div class="input-group">
                        <label for="initialTarget">Initial Target (åˆå§‹ç›®æ ‡é•¿åº¦):</label>
                        <input type="number" id="initialTarget" value="100" min="1" max="32768">
                    </div>
                    <div class="input-group">
                        <label for="maxLength">Max Length (æœ€å¤§ç”Ÿæˆé•¿åº¦):</label>
                        <input type="number" id="maxLength" value="512" min="1" max="2048">
                    </div>
                    <div class="input-group">
                        <label for="temperature">Temperature (é‡‡æ ·æ¸©åº¦):</label>
                        <input type="number" id="temperature" value="1.0" min="0.1" max="2.0" step="0.1">
                    </div>
                    <div class="input-group">
                        <label for="topK">Top-K (é‡‡æ ·èŒƒå›´):</label>
                        <input type="number" id="topK" value="50" min="0" max="1000" step="1">
                    </div>
                    <div class="input-group">
                        <label for="topP">Top-P (æ ¸é‡‡æ ·):</label>
                        <input type="number" id="topP" value="0.9" min="0.0" max="1.0" step="0.05">
                    </div>
                    <div class="input-group">
                        <label for="pplWindowSize">PPL Window Size (å›°æƒ‘åº¦çª—å£å¤§å°):</label>
                        <input type="number" id="pplWindowSize" value="512" min="10" max="2048" step="1">
                    </div>
                    <div class="button-group">
                        <button class="btn-primary" id="generateBtn" onclick="startGeneration()">
                            ğŸš€ å¼€å§‹ç”Ÿæˆ
                        </button>
                        <button class="btn-danger" id="stopBtn" onclick="stopGeneration()" disabled>
                            â¹ï¸ åœæ­¢
                        </button>
                    </div>
                </div>


                <!-- API æ§åˆ¶è§„åˆ’ -->
                <div class="card">
                    <h2>ğŸ¯ API æ§åˆ¶è§„åˆ’</h2>
                    <div class="input-group">
                        <label for="controlStrategy">æ§åˆ¶ç­–ç•¥:</label>
                        <select id="controlStrategy" style="width: 100%; padding: 12px; border: 2px solid #ddd; border-radius: 8px; font-size: 1em;">
                            <option value="none">æ— æ§åˆ¶ (ä½¿ç”¨predicted_target)</option>
                            <option value="partial">éƒ¨åˆ†æ§åˆ¶ (å‰Næ­¥ä½¿ç”¨è§„åˆ’)</option>
                            <option value="full">å…¨ç¨‹æ§åˆ¶ (å…¨ç¨‹ä½¿ç”¨è§„åˆ’)</option>
                        </select>
                    </div>
                    <div class="input-group" id="compellingStepsGroup" style="display: none;">
                        <label for="compellingSteps">å¼ºåˆ¶æ§åˆ¶æ­¥æ•° (Compelling Steps):</label>
                        <input type="number" id="compellingSteps" value="50" min="0" max="1000">
                    </div>
                    <div class="input-group">
                        <label for="controlPoints">æ§åˆ¶ç‚¹ (JSONæ ¼å¼):</label>
                        <textarea id="controlPoints" style="min-height: 120px; font-family: 'Courier New', monospace; font-size: 0.9em;" placeholder='ç¤ºä¾‹: [[0, 1], [1, 0]]&#10;&#10;æ ¼å¼è¯´æ˜:&#10;- æ¨ªåæ ‡: å·²è¾“å‡ºtoken / initial_target&#10;- çºµåæ ‡: è¾“å…¥target / initial_target&#10;- ç¬¬ä¸€ä¸ªç‚¹å¿…é¡»æ˜¯ [0, 1]&#10;- æœ€åä¸€ä¸ªç‚¹çš„yå€¼å¿…é¡»æ˜¯ 0'>[[0, 1], [1, 0]]</textarea>
                    </div>
                    <div style="margin-top: 10px; padding: 10px; background: #e7f3ff; border-radius: 5px; font-size: 0.85em;">
                        <strong>ğŸ’¡ æç¤º:</strong><br>
                        â€¢ çº¿æ€§é€’å‡: [[0,1], [1,0]] (æ–œç‡=-1)<br>
                        â€¢ å¿«é€Ÿé€’å‡: [[0,1], [0.5,0]] (å‰åŠæ®µå¿«é€Ÿ)<br>
                        â€¢ æ…¢é€Ÿé€’å‡: [[0,1], [2,0]] (å»¶é•¿ç”Ÿæˆ)
                    </div>
                </div>

                <!-- å®æ—¶ç»Ÿè®¡ -->
                <div class="card">
                    <h2>ğŸ“Š å®æ—¶ç»Ÿè®¡</h2>
                    <div class="stats-grid">
                        <div class="stat-card">
                            <div class="label">å·²è¾“å‡º Token æ•°</div>
                            <div class="value" id="totalTokens">0</div>
                        </div>
                        <div class="stat-card">
                            <div class="label">è¾“å‡º Target æ•°å€¼</div>
                            <div class="value" id="outputTargetValue">-</div>
                        </div>
                        <div class="stat-card">
                            <div class="label">Cosine ç›¸ä¼¼åº¦</div>
                            <div class="value" id="cosineValue">-</div>
                        </div>
                        <div class="stat-card">
                            <div class="label">å½“å‰æ­¥æ•°</div>
                            <div class="value" id="currentStep">0</div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- å³ä¾§é¢æ¿ -->
            <div class="right-panel">
                <!-- ç”Ÿæˆè¾“å‡º -->
                <div class="card">
                    <h2>ğŸ’¬ ç”Ÿæˆè¾“å‡º</h2>
                    <div class="output-box" id="outputBox">ç­‰å¾…ç”Ÿæˆ...</div>
                </div>

                <!-- è¯¦ç»†ä¿¡æ¯ -->
                <div class="card">
                    <h2>ğŸ” è¯¦ç»†ä¿¡æ¯</h2>
                    <div class="output-box" id="detailsBox" style="max-height: 300px; font-size: 0.85em;">
                        ç­‰å¾…ç”Ÿæˆ...
                    </div>
                </div>
            </div>

            <!-- å›¾è¡¨åŒºåŸŸ -->
            <div class="charts-section" id="chartsSection" style="display: none;">
                <div class="card">
                    <h2>ğŸ“‰ PPL (å›°æƒ‘åº¦) æ›²çº¿</h2>
                    <div class="chart-container">
                        <canvas id="pplChart" style="height: 300px;"></canvas>
                    </div>
                    <div class="stats-grid" style="margin-top: 15px;">
                        <div class="stat-card">
                            <div class="label">å‡å€¼ (Mean)</div>
                            <div class="value" id="pplMean" style="font-size: 1.4em;">-</div>
                        </div>
                        <div class="stat-card">
                            <div class="label">æ–¹å·® (Variance)</div>
                            <div class="value" id="pplVariance" style="font-size: 1.4em;">-</div>
                        </div>
                        <div class="stat-card">
                            <div class="label">æœ€å°å€¼ (Min)</div>
                            <div class="value" id="pplMin" style="font-size: 1.4em;">-</div>
                        </div>
                        <div class="stat-card">
                            <div class="label">æœ€å¤§å€¼ (Max)</div>
                            <div class="value" id="pplMax" style="font-size: 1.4em;">-</div>
                        </div>
                    </div>
                </div>
                <div class="card">
                    <h2>ğŸ“‰ Cosine ç›¸ä¼¼åº¦æ›²çº¿</h2>
                    <div class="chart-container">
                        <canvas id="cosineChart" style="height: 300px;"></canvas>
                    </div>
                    <div class="stats-grid" style="margin-top: 15px;">
                        <div class="stat-card">
                            <div class="label">å‡å€¼ (Mean)</div>
                            <div class="value" id="cosineMean" style="font-size: 1.4em;">-</div>
                        </div>
                        <div class="stat-card">
                            <div class="label">æ–¹å·® (Variance)</div>
                            <div class="value" id="cosineVariance" style="font-size: 1.4em;">-</div>
                        </div>
                    </div>
                </div>
                <div class="card">
                    <h2>ğŸ“Š Target vs å·²è¾“å‡ºTokenå…³ç³»å›¾</h2>
                    <div class="chart-container-square">
                        <canvas id="targetVsTokenChart"></canvas>
                    </div>
                    <div style="margin-top: 15px; padding: 15px; background: white; border-radius: 8px; font-family: 'Courier New', monospace; font-size: 0.9em;">
                        <div style="margin-bottom: 10px; font-weight: bold; color: #667eea;">æ‹Ÿåˆç›´çº¿æ–¹ç¨‹:</div>
                        <div id="fitEquation" style="margin-bottom: 10px; color: #333;">y = b + a*x</div>
                        <div style="margin-bottom: 10px; font-weight: bold; color: #667eea;">æŸå¤±å‡½æ•° (MSE):</div>
                        <div id="mseLoss" style="margin-bottom: 10px; color: #333;">L = (1/n) * Î£(y_i - Å·_i)Â²</div>
                        <div style="margin-bottom: 10px; font-weight: bold; color: #667eea;">å†³å®šç³»æ•° (RÂ²):</div>
                        <div id="r2Score" style="color: #333;">RÂ² = 1 - (SS_res / SS_tot)</div>
                    </div>
                </div>
                <div class="card">
                    <h2>ğŸ¯ è¾“å…¥ Target å€¼æ›²çº¿</h2>
                    <div class="chart-container-square">
                        <canvas id="inputTargetChart"></canvas>
                    </div>
                </div>
                <div class="card">
                    <h2>ğŸ“Š Predicted vs Input Target å¯¹æ¯”</h2>
                    <div class="chart-container-square">
                        <canvas id="comparisonChart"></canvas>
                    </div>
                    <div id="segmentMseSection" style="display: none; margin-top: 15px; padding: 15px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px;">
                        <div style="margin-bottom: 10px; font-weight: bold; color: #856404; font-size: 1.1em;">ğŸ“Š åˆ†æ®µMSEåˆ†æ (å…¨å±€æ§åˆ¶ç­–ç•¥)</div>
                        <div id="segmentMseDetails" style="font-family: 'Courier New', monospace; font-size: 0.9em; color: #333;"></div>
                        <div style="margin-top: 10px; padding: 10px; background: white; border-radius: 5px;">
                            <div style="font-weight: bold; color: #667eea; margin-bottom: 5px;">åŠ æƒå¹³å‡MSE:</div>
                            <div id="weightedMse" style="font-size: 1.3em; color: #dc3545; font-weight: bold;">-</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let ws = null;
        let isGenerating = false;
        let generatedText = '';
        let historyData = [];
        let updateInterval = null;
        let cosineChart = null;
        let pplChart = null;
        let targetVsTokenChart = null;
        let inputTargetChart = null;
        let comparisonChart = null;
        let currentControlPoints = null;
        let currentControlStrategy = 'none';
        let currentInitialTarget = 100;
        let reconnectTimer = null;  // ç”¨äºè·Ÿè¸ªé‡è¿å®šæ—¶å™¨

        // WebSocket è¿æ¥
        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//${window.location.host}/ws`;

            console.log('Connecting to:', wsUrl);
            updateStatus('connecting', 'æ­£åœ¨è¿æ¥...');

            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log('WebSocket connected');
                updateStatus('connected', 'å·²è¿æ¥');
            };

            ws.onmessage = (event) => {
                const message = JSON.parse(event.data);
                handleMessage(message);
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                updateStatus('disconnected', 'è¿æ¥é”™è¯¯');
            };

            ws.onclose = () => {
                console.log('WebSocket closed');
                updateStatus('disconnected', 'è¿æ¥æ–­å¼€');

                // æ¸…é™¤ä»»ä½•ç°æœ‰çš„é‡è¿å®šæ—¶å™¨
                if (reconnectTimer) {
                    clearTimeout(reconnectTimer);
                    reconnectTimer = null;
                }

                // 5ç§’åè‡ªåŠ¨é‡è¿ï¼ˆä»…åœ¨éæ‰‹åŠ¨åœæ­¢çš„æƒ…å†µä¸‹ï¼‰
                if (!isGenerating) {
                    reconnectTimer = setTimeout(() => {
                        if (!ws || ws.readyState === WebSocket.CLOSED) {
                            connectWebSocket();
                        }
                        reconnectTimer = null;
                    }, 5000);
                }
            };
        }

        // æ›´æ–°è¿æ¥çŠ¶æ€
        function updateStatus(status, text) {
            const indicator = document.getElementById('statusIndicator');
            const statusText = document.getElementById('statusText');
            const spinner = document.getElementById('loadingSpinner');

            indicator.className = 'status-indicator';

            if (status === 'connected') {
                indicator.classList.add('status-connected');
                spinner.style.display = 'none';
            } else if (status === 'disconnected') {
                indicator.classList.add('status-disconnected');
                spinner.style.display = 'none';
            } else if (status === 'generating') {
                indicator.classList.add('status-generating');
                spinner.style.display = 'inline-block';
            } else if (status === 'connecting') {
                indicator.classList.add('status-disconnected');
                spinner.style.display = 'inline-block';
            }

            statusText.textContent = text;
        }

        // å¤„ç† WebSocket æ¶ˆæ¯
        function handleMessage(message) {
            if (message.type === 'step') {
                // å•æ­¥æ•°æ®
                const data = message.data;
                historyData.push(data);

                // æ›´æ–°ç”Ÿæˆæ–‡æœ¬
                generatedText += data.token_text;
                document.getElementById('outputBox').textContent = generatedText;

                // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
                updateStats(data);

                // æ›´æ–°è¯¦ç»†ä¿¡æ¯
                updateDetails(data);

            } else if (message.type === 'complete') {
                // ç”Ÿæˆå®Œæˆ
                console.log('Generation complete');
                historyData = message.history;
                isGenerating = false;

                updateStatus('connected', 'å·²è¿æ¥');
                document.getElementById('generateBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;

                // æ˜¾ç¤ºå›¾è¡¨
                showCharts();

            }
        }

        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        function updateStats(data) {
            document.getElementById('totalTokens').textContent = data.total_tokens;
            document.getElementById('outputTargetValue').textContent = data.output_target_value.toFixed(2);
            document.getElementById('cosineValue').textContent = data.cosine_similarity.toFixed(4);
            document.getElementById('currentStep').textContent = data.step;
        }

        // æ›´æ–°è¯¦ç»†ä¿¡æ¯
        function updateDetails(data) {
            const detailsBox = document.getElementById('detailsBox');
            const detail = `
[Step ${data.step}]
Token: "${data.token_text}" (ID: ${data.token_id})
Input Target Value: ${data.input_target_value.toFixed(2)}
Output Target Value: ${data.output_target_value.toFixed(2)}
Output Target Norm: ${data.output_target_norm.toFixed(4)}
Cosine Similarity: ${data.cosine_similarity.toFixed(4)}
Total Tokens: ${data.total_tokens}
${'='.repeat(50)}
`;
            detailsBox.textContent = detail + detailsBox.textContent;
        }

        // å¼€å§‹ç”Ÿæˆ
        function startGeneration() {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                alert('WebSocket æœªè¿æ¥ï¼Œè¯·ç­‰å¾…è¿æ¥å»ºç«‹');
                return;
            }

            // é‡ç½®çŠ¶æ€
            generatedText = '';
            historyData = [];
            document.getElementById('outputBox').textContent = 'ç”Ÿæˆä¸­...';
            document.getElementById('detailsBox').textContent = '';
            document.getElementById('chartsSection').style.display = 'none';

            // é‡ç½®ç»Ÿè®¡
            document.getElementById('totalTokens').textContent = '0';
            document.getElementById('outputTargetValue').textContent = '-';
            document.getElementById('cosineValue').textContent = '-';
            document.getElementById('currentStep').textContent = '0';

            // è·å–å‚æ•°
            const prompt = document.getElementById('promptInput').value;
            const initialTarget = parseFloat(document.getElementById('initialTarget').value);
            const maxLength = parseInt(document.getElementById('maxLength').value);
            const temperature = parseFloat(document.getElementById('temperature').value);
            const topK = parseInt(document.getElementById('topK').value);
            const topP = parseFloat(document.getElementById('topP').value);
            const pplWindowSize = parseInt(document.getElementById('pplWindowSize').value);

            // è·å–æ§åˆ¶å‚æ•°
            const controlStrategy = document.getElementById('controlStrategy').value;
            const compellingSteps = parseInt(document.getElementById('compellingSteps').value);
            let controlPoints = null;

            // è§£ææ§åˆ¶ç‚¹
            if (controlStrategy !== 'none') {
                try {
                    const controlPointsText = document.getElementById('controlPoints').value;
                    controlPoints = JSON.parse(controlPointsText);

                    // éªŒè¯æ§åˆ¶ç‚¹æ ¼å¼
                    if (!Array.isArray(controlPoints)) {
                        throw new Error('æ§åˆ¶ç‚¹å¿…é¡»æ˜¯æ•°ç»„');
                    }
                    for (let point of controlPoints) {
                        if (!Array.isArray(point) || point.length !== 2) {
                            throw new Error('æ¯ä¸ªæ§åˆ¶ç‚¹å¿…é¡»æ˜¯ [x, y] æ ¼å¼');
                        }
                    }

                    console.log('Parsed control points:', controlPoints);
                } catch (e) {
                    alert('æ§åˆ¶ç‚¹æ ¼å¼é”™è¯¯: ' + e.message);
                    return;
                }
            }

            // ä¿å­˜æ§åˆ¶å‚æ•°åˆ°å…¨å±€å˜é‡
            currentControlPoints = controlPoints;
            currentControlStrategy = controlStrategy;
            currentInitialTarget = initialTarget;

            // å‘é€ç”Ÿæˆè¯·æ±‚
            ws.send(JSON.stringify({
                type: 'generate',
                prompt: prompt,
                initial_target: initialTarget,
                max_length: maxLength,
                temperature: temperature,
                top_k: topK,
                top_p: topP,
                control_points: controlPoints,
                control_strategy: controlStrategy,
                compelling_steps: compellingSteps,
                ppl_window_size: pplWindowSize
            }));

            isGenerating = true;
            updateStatus('generating', 'ç”Ÿæˆä¸­...');
            document.getElementById('generateBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
        }

        // åœæ­¢ç”Ÿæˆ
        function stopGeneration() {
            // å…ˆè®¾ç½®æ ‡å¿—ï¼Œé˜²æ­¢ onclose è§¦å‘è‡ªåŠ¨é‡è¿
            isGenerating = false;

            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.close();
            }

            updateStatus('disconnected', 'å·²åœæ­¢');
            document.getElementById('generateBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;

            // æ¸…é™¤ä»»ä½•ç°æœ‰çš„é‡è¿å®šæ—¶å™¨
            if (reconnectTimer) {
                clearTimeout(reconnectTimer);
                reconnectTimer = null;
            }

            // é‡æ–°è¿æ¥ï¼ˆåªè®¾ç½®ä¸€æ¬¡ï¼‰
            reconnectTimer = setTimeout(() => {
                connectWebSocket();
                reconnectTimer = null;
            }, 1000);
        }


        // è®¡ç®—çº¿æ€§å›å½’
        function linearRegression(x, y) {
            const n = x.length;
            let sumX = 0, sumY = 0, sumXY = 0, sumX2 = 0;

            for (let i = 0; i < n; i++) {
                sumX += x[i];
                sumY += y[i];
                sumXY += x[i] * y[i];
                sumX2 += x[i] * x[i];
            }

            const a = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
            const b = (sumY - a * sumX) / n;

            return { a, b };
        }

        // è®¡ç®— MSE
        function calculateMSE(x, y, a, b) {
            const n = x.length;
            let sumSquaredError = 0;

            for (let i = 0; i < n; i++) {
                const predicted = b + a * x[i];
                const error = y[i] - predicted;
                sumSquaredError += error * error;
            }

            return sumSquaredError / n;
        }

        // è®¡ç®— RÂ²
        function calculateR2(x, y, a, b) {
            const n = x.length;
            const meanY = y.reduce((sum, val) => sum + val, 0) / n;

            let ssRes = 0;  // æ®‹å·®å¹³æ–¹å’Œ
            let ssTot = 0;  // æ€»å¹³æ–¹å’Œ

            for (let i = 0; i < n; i++) {
                const predicted = b + a * x[i];
                ssRes += (y[i] - predicted) ** 2;
                ssTot += (y[i] - meanY) ** 2;
            }

            return 1 - (ssRes / ssTot);
        }

        // è®¡ç®—å‡å€¼
        function calculateMean(values) {
            return values.reduce((sum, val) => sum + val, 0) / values.length;
        }

        // è®¡ç®—æ–¹å·®
        function calculateVariance(values) {
            const mean = calculateMean(values);
            const squaredDiffs = values.map(val => (val - mean) ** 2);
            return squaredDiffs.reduce((sum, val) => sum + val, 0) / values.length;
        }

        // è®¡ç®—è§„åˆ’æ›²çº¿ä¸Šçš„å€¼ï¼ˆæ”¯æŒçº¿æ®µå»¶ä¼¸ï¼‰
        function getPlannedValue(x, controlPoints, initialTarget) {
            // x: å·²è¾“å‡ºtokenæ•°ï¼ˆå½’ä¸€åŒ–å‰ï¼‰
            // controlPoints: [[x1, y1], [x2, y2], ...] (å½’ä¸€åŒ–åæ ‡)
            // initialTarget: åˆå§‹targetå€¼

            const xNorm = x / initialTarget;  // å½’ä¸€åŒ–xåæ ‡

            // æ‰¾åˆ°xæ‰€åœ¨çš„çº¿æ®µ
            for (let i = 0; i < controlPoints.length - 1; i++) {
                const [x1, y1] = controlPoints[i];
                const [x2, y2] = controlPoints[i + 1];

                if (xNorm >= x1 && xNorm <= x2) {
                    // åœ¨çº¿æ®µå†…ï¼Œçº¿æ€§æ’å€¼
                    const t = (xNorm - x1) / (x2 - x1);
                    const yNorm = y1 + t * (y2 - y1);
                    return yNorm * initialTarget;
                }
            }

            // å¦‚æœè¶…å‡ºæœ€åä¸€ä¸ªæ§åˆ¶ç‚¹ï¼Œå»¶ä¼¸æœ€åä¸€æ®µçº¿æ®µ
            if (xNorm > controlPoints[controlPoints.length - 1][0]) {
                const lastIdx = controlPoints.length - 1;
                const [x1, y1] = controlPoints[lastIdx - 1];
                const [x2, y2] = controlPoints[lastIdx];

                // è®¡ç®—æ–œç‡
                const slope = (y2 - y1) / (x2 - x1);

                // å»¶ä¼¸çº¿æ®µ
                const yNorm = y2 + slope * (xNorm - x2);
                return yNorm * initialTarget;
            }

            // å¦‚æœåœ¨ç¬¬ä¸€ä¸ªæ§åˆ¶ç‚¹ä¹‹å‰ï¼Œè¿”å›ç¬¬ä¸€ä¸ªç‚¹çš„å€¼
            return controlPoints[0][1] * initialTarget;
        }

        // è®¡ç®—åˆ†æ®µMSE
        function calculateSegmentMSE(totalTokens, predictedValues, controlPoints, initialTarget) {
            // ç¡®ä¿æ§åˆ¶ç‚¹æŒ‰xæ’åº
            const sortedPoints = [...controlPoints].sort((a, b) => a[0] - b[0]);

            const segments = [];

            // å¯¹æ¯ä¸ªçº¿æ®µè®¡ç®—MSE
            for (let i = 0; i < sortedPoints.length - 1; i++) {
                const [x1Norm, y1Norm] = sortedPoints[i];
                const [x2Norm, y2Norm] = sortedPoints[i + 1];

                // è½¬æ¢ä¸ºå®é™…åæ ‡
                const x1 = x1Norm * initialTarget;
                const x2 = x2Norm * initialTarget;

                // æ‰¾åˆ°è¯¥çº¿æ®µèŒƒå›´å†…çš„æ•°æ®ç‚¹
                const segmentData = [];
                for (let j = 0; j < totalTokens.length; j++) {
                    const token = totalTokens[j];
                    if (token >= x1 && token <= x2) {
                        const plannedValue = getPlannedValue(token, sortedPoints, initialTarget);
                        const predictedValue = predictedValues[j];
                        segmentData.push({
                            token: token,
                            predicted: predictedValue,
                            planned: plannedValue,
                            error: (predictedValue - plannedValue) ** 2
                        });
                    }
                }

                // è®¡ç®—è¯¥çº¿æ®µçš„MSE
                if (segmentData.length > 0) {
                    const mse = segmentData.reduce((sum, d) => sum + d.error, 0) / segmentData.length;
                    segments.push({
                        segmentIndex: i,
                        x1: x1,
                        x2: x2,
                        y1: y1Norm * initialTarget,
                        y2: y2Norm * initialTarget,
                        dataCount: segmentData.length,
                        mse: mse
                    });
                }
            }

            // æ£€æŸ¥æ˜¯å¦æœ‰è¶…å‡ºæœ€åä¸€ä¸ªæ§åˆ¶ç‚¹çš„æ•°æ®ï¼ˆéœ€è¦å»¶ä¼¸çº¿æ®µï¼‰
            const lastX = sortedPoints[sortedPoints.length - 1][0] * initialTarget;
            const extendedData = [];
            for (let j = 0; j < totalTokens.length; j++) {
                const token = totalTokens[j];
                if (token > lastX) {
                    const plannedValue = getPlannedValue(token, sortedPoints, initialTarget);
                    const predictedValue = predictedValues[j];
                    extendedData.push({
                        token: token,
                        predicted: predictedValue,
                        planned: plannedValue,
                        error: (predictedValue - plannedValue) ** 2
                    });
                }
            }

            // å¦‚æœæœ‰å»¶ä¼¸æ®µæ•°æ®ï¼Œæ·»åŠ åˆ°segments
            if (extendedData.length > 0) {
                const mse = extendedData.reduce((sum, d) => sum + d.error, 0) / extendedData.length;
                const lastIdx = sortedPoints.length - 1;
                segments.push({
                    segmentIndex: lastIdx,
                    x1: lastX,
                    x2: Math.max(...totalTokens),
                    y1: sortedPoints[lastIdx][1] * initialTarget,
                    y2: getPlannedValue(Math.max(...totalTokens), sortedPoints, initialTarget),
                    dataCount: extendedData.length,
                    mse: mse,
                    isExtended: true
                });
            }

            // è®¡ç®—åŠ æƒå¹³å‡MSE
            const totalDataCount = segments.reduce((sum, seg) => sum + seg.dataCount, 0);
            const weightedMSE = segments.reduce((sum, seg) => {
                const weight = seg.dataCount / totalDataCount;
                return sum + weight * seg.mse;
            }, 0);

            return {
                segments: segments,
                weightedMSE: weightedMSE,
                totalDataCount: totalDataCount
            };
        }

        // æ˜¾ç¤ºå›¾è¡¨
        function showCharts() {
            document.getElementById('chartsSection').style.display = 'grid';

            // å‡†å¤‡æ•°æ®
            const steps = historyData.map(d => d.step);
            const totalTokens = historyData.map(d => d.total_tokens);
            const targetValues = historyData.map(d => d.output_target_value);
            const cosineValues = historyData.map(d => d.cosine_similarity);
            const inputTargetValues = historyData.map(d => d.input_target_value);
            const plannedTargetValues = historyData.map(d => d.planned_target_value || 0);
            const pplValues = historyData.map(d => d.ppl).filter(p => p !== null && p !== undefined);

            // é”€æ¯æ—§å›¾è¡¨
            if (pplChart) pplChart.destroy();
            if (cosineChart) cosineChart.destroy();
            if (targetVsTokenChart) targetVsTokenChart.destroy();
            if (inputTargetChart) inputTargetChart.destroy();
            if (comparisonChart) comparisonChart.destroy();

            // è®¡ç®— PPL ç»Ÿè®¡ä¿¡æ¯
            if (pplValues.length > 0) {
                const pplMean = calculateMean(pplValues);
                const pplVariance = calculateVariance(pplValues);
                const pplMin = Math.min(...pplValues);
                const pplMax = Math.max(...pplValues);

                document.getElementById('pplMean').textContent = pplMean.toFixed(2);
                document.getElementById('pplVariance').textContent = pplVariance.toFixed(2);
                document.getElementById('pplMin').textContent = pplMin.toFixed(2);
                document.getElementById('pplMax').textContent = pplMax.toFixed(2);

                // åˆ›å»º PPL å›¾è¡¨
                const pplTokens = historyData
                    .filter(d => d.ppl !== null && d.ppl !== undefined)
                    .map(d => d.total_tokens);

                const pplCtx = document.getElementById('pplChart').getContext('2d');
                pplChart = new Chart(pplCtx, {
                    type: 'line',
                    data: {
                        labels: pplTokens,
                        datasets: [{
                            label: 'PPL (å›°æƒ‘åº¦)',
                            data: pplValues,
                            borderColor: '#28a745',
                            backgroundColor: 'rgba(40, 167, 69, 0.1)',
                            borderWidth: 2,
                            tension: 0.4,
                            fill: true
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                display: true,
                                position: 'top'
                            },
                            title: {
                                display: false
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return `PPL: ${context.parsed.y.toFixed(2)}`;
                                    }
                                }
                            }
                        },
                        scales: {
                            x: {
                                title: {
                                    display: true,
                                    text: 'å·²è¾“å‡º Token æ•°'
                                }
                            },
                            y: {
                                title: {
                                    display: true,
                                    text: 'Perplexity (å›°æƒ‘åº¦)'
                                },
                                beginAtZero: false
                            }
                        }
                    }
                });
            }

            // è®¡ç®— Cosine ç»Ÿè®¡ä¿¡æ¯
            const cosineMean = calculateMean(cosineValues);
            const cosineVariance = calculateVariance(cosineValues);

            document.getElementById('cosineMean').textContent = cosineMean.toFixed(6);
            document.getElementById('cosineVariance').textContent = cosineVariance.toFixed(6);

            // åˆ›å»º Cosine ç›¸ä¼¼åº¦å›¾è¡¨
            const cosineCtx = document.getElementById('cosineChart').getContext('2d');
            cosineChart = new Chart(cosineCtx, {
                type: 'line',
                data: {
                    labels: steps,
                    datasets: [{
                        label: 'Cosine ç›¸ä¼¼åº¦',
                        data: cosineValues,
                        borderColor: '#764ba2',
                        backgroundColor: 'rgba(118, 75, 162, 0.1)',
                        borderWidth: 2,
                        tension: 0.4,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        title: {
                            display: false
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'å·²è¾“å‡º Token æ•°'
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Cosine ç›¸ä¼¼åº¦'
                            },
                            beginAtZero: false
                        }
                    }
                }
            });

            // è®¡ç®—çº¿æ€§å›å½’ï¼ˆé’ˆå¯¹ output_targetï¼‰
            const { a, b } = linearRegression(totalTokens, targetValues);
            const mse = calculateMSE(totalTokens, targetValues, a, b);
            const r2 = calculateR2(totalTokens, targetValues, a, b);

            // ç”Ÿæˆæ‹Ÿåˆçº¿æ•°æ®
            const minToken = Math.min(...totalTokens);
            const maxToken = Math.max(...totalTokens);
            const fittedLine = [
                { x: minToken, y: b + a * minToken },
                { x: maxToken, y: b + a * maxToken }
            ];

            // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯æ˜¾ç¤º
            document.getElementById('fitEquation').textContent =
                `y = ${b.toFixed(4)} + ${a.toFixed(4)} * x`;
            document.getElementById('mseLoss').textContent =
                `L = ${mse.toFixed(4)}`;
            document.getElementById('r2Score').textContent =
                `RÂ² = ${r2.toFixed(6)}`;

            // è®¡ç®—ç»Ÿä¸€çš„åæ ‡è½´èŒƒå›´ï¼ˆå¼ºåˆ¶ X-Y æ¯”ä¾‹å°ºç»Ÿä¸€ï¼‰
            const allValues = [...totalTokens, ...targetValues];
            const minVal = Math.min(...allValues);
            const maxVal = Math.max(...allValues);
            const range = maxVal - minVal;
            const padding = range * 0.1;
            const axisMin = Math.floor(minVal - padding);
            const axisMax = Math.ceil(maxVal + padding);

            // åˆ›å»º Target vs Token å…³ç³»å›¾ï¼ˆç»Ÿä¸€æ¯”ä¾‹å°ºï¼‰
            const targetVsTokenCtx = document.getElementById('targetVsTokenChart').getContext('2d');
            targetVsTokenChart = new Chart(targetVsTokenCtx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: 'å®é™…æ•°æ®ç‚¹',
                            data: totalTokens.map((token, i) => ({ x: token, y: targetValues[i] })),
                            backgroundColor: 'rgba(102, 126, 234, 0.6)',
                            borderColor: '#667eea',
                            borderWidth: 1,
                            pointRadius: 4,
                            pointHoverRadius: 6
                        },
                        {
                            label: 'æ‹Ÿåˆç›´çº¿',
                            data: fittedLine,
                            type: 'line',
                            borderColor: '#dc3545',
                            backgroundColor: 'rgba(220, 53, 69, 0.1)',
                            borderWidth: 3,
                            pointRadius: 0,
                            fill: false,
                            tension: 0
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 1,  // å¼ºåˆ¶ 1:1 æ¯”ä¾‹
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        title: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    if (context.datasetIndex === 0) {
                                        return `Token: ${context.parsed.x}, Target: ${context.parsed.y.toFixed(2)}`;
                                    } else {
                                        return `æ‹Ÿåˆå€¼: ${context.parsed.y.toFixed(2)}`;
                                    }
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'å·²è¾“å‡º Token æ•° (x)',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            min: axisMin,
                            max: axisMax,
                            ticks: {
                                stepSize: Math.ceil(range / 10)
                            }
                        },
                        y: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Target æ•°å€¼ (y)',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            min: axisMin,
                            max: axisMax,
                            ticks: {
                                stepSize: Math.ceil(range / 10)
                            }
                        }
                    }
                }
            });

            // åˆ›å»ºè¾“å…¥ Target å€¼æ›²çº¿å›¾ï¼ˆç»Ÿä¸€æ¯”ä¾‹å°ºï¼‰
            const inputTargetCtx = document.getElementById('inputTargetChart').getContext('2d');
            inputTargetChart = new Chart(inputTargetCtx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'è¾“å…¥ Target å€¼',
                        data: totalTokens.map((token, i) => ({ x: token, y: inputTargetValues[i] })),
                        backgroundColor: 'rgba(40, 167, 69, 0.6)',
                        borderColor: '#28a745',
                        borderWidth: 1,
                        pointRadius: 4,
                        pointHoverRadius: 6,
                        showLine: true,
                        tension: 0.4
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 1,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        title: {
                            display: false
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    return `Token: ${context.parsed.x}, Input Target: ${context.parsed.y.toFixed(2)}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'å·²è¾“å‡º Token æ•° (x)',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            min: axisMin,
                            max: axisMax,
                            ticks: {
                                stepSize: Math.ceil(range / 10)
                            }
                        },
                        y: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'è¾“å…¥ Target å€¼ (y)',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            min: axisMin,
                            max: axisMax,
                            ticks: {
                                stepSize: Math.ceil(range / 10)
                            }
                        }
                    }
                }
            });

            // åˆ›å»ºå¯¹æ¯”å›¾ï¼ˆPredicted vs Input Targetï¼‰ï¼ˆç»Ÿä¸€æ¯”ä¾‹å°ºï¼‰
            const comparisonCtx = document.getElementById('comparisonChart').getContext('2d');
            comparisonChart = new Chart(comparisonCtx, {
                type: 'line',
                data: {
                    labels: totalTokens,
                    datasets: [
                        {
                            label: 'Predicted Target (è¾“å‡º)',
                            data: targetValues,
                            borderColor: '#667eea',
                            backgroundColor: 'rgba(102, 126, 234, 0.1)',
                            borderWidth: 2,
                            tension: 0.4,
                            fill: false,
                            pointRadius: 3
                        },
                        {
                            label: 'Input Target (è¾“å…¥)',
                            data: inputTargetValues,
                            borderColor: '#28a745',
                            backgroundColor: 'rgba(40, 167, 69, 0.1)',
                            borderWidth: 2,
                            tension: 0.4,
                            fill: false,
                            pointRadius: 3
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: true,
                    aspectRatio: 1,
                    plugins: {
                        legend: {
                            display: true,
                            position: 'top'
                        },
                        title: {
                            display: false
                        }
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'å·²è¾“å‡º Token æ•° (x)',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            min: axisMin,
                            max: axisMax,
                            ticks: {
                                stepSize: Math.ceil(range / 10)
                            }
                        },
                        y: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Target å€¼ (y)',
                                font: {
                                    size: 14,
                                    weight: 'bold'
                                }
                            },
                            min: axisMin,
                            max: axisMax,
                            ticks: {
                                stepSize: Math.ceil(range / 10)
                            }
                        }
                    }
                }
            });

            // è®¡ç®—å¹¶æ˜¾ç¤ºåˆ†æ®µMSEï¼ˆä»…åœ¨å…¨å±€æ§åˆ¶ç­–ç•¥æ—¶ï¼‰
            if (currentControlStrategy === 'full' && currentControlPoints && currentControlPoints.length > 0) {
                try {
                    const mseResult = calculateSegmentMSE(
                        totalTokens,
                        targetValues,
                        currentControlPoints,
                        currentInitialTarget
                    );

                    // æ˜¾ç¤ºMSEåŒºåŸŸ
                    document.getElementById('segmentMseSection').style.display = 'block';

                    // æ„å»ºè¯¦ç»†ä¿¡æ¯HTML
                    let detailsHtml = '';
                    mseResult.segments.forEach((seg, idx) => {
                        const segmentLabel = seg.isExtended ? 'å»¶ä¼¸æ®µ' : `çº¿æ®µ ${seg.segmentIndex + 1}`;
                        detailsHtml += `
<div style="margin-bottom: 10px; padding: 10px; background: white; border-left: 4px solid ${seg.isExtended ? '#dc3545' : '#667eea'}; border-radius: 3px;">
    <div style="font-weight: bold; color: ${seg.isExtended ? '#dc3545' : '#667eea'};">${segmentLabel}</div>
    <div style="margin-top: 5px;">
        <span style="color: #666;">èŒƒå›´:</span> x âˆˆ [${seg.x1.toFixed(1)}, ${seg.x2.toFixed(1)}]
    </div>
    <div>
        <span style="color: #666;">è§„åˆ’å€¼:</span> y âˆˆ [${seg.y1.toFixed(2)}, ${seg.y2.toFixed(2)}]
    </div>
    <div>
        <span style="color: #666;">æ•°æ®ç‚¹æ•°:</span> ${seg.dataCount}
    </div>
    <div>
        <span style="color: #666;">MSE:</span> <span style="color: #dc3545; font-weight: bold;">${seg.mse.toFixed(4)}</span>
    </div>
    <div>
        <span style="color: #666;">æƒé‡:</span> ${(seg.dataCount / mseResult.totalDataCount * 100).toFixed(1)}%
    </div>
</div>`;
                    });

                    document.getElementById('segmentMseDetails').innerHTML = detailsHtml;
                    document.getElementById('weightedMse').textContent = mseResult.weightedMSE.toFixed(4);

                    console.log('Segment MSE Analysis:', mseResult);
                } catch (error) {
                    console.error('Error calculating segment MSE:', error);
                    document.getElementById('segmentMseSection').style.display = 'none';
                }
            } else {
                // éå…¨å±€æ§åˆ¶ç­–ç•¥ï¼Œéšè—MSEåŒºåŸŸ
                document.getElementById('segmentMseSection').style.display = 'none';
            }
        }

        // æ§åˆ¶ç­–ç•¥é€‰æ‹©å™¨äº‹ä»¶
        function onControlStrategyChange() {
            const strategy = document.getElementById('controlStrategy').value;
            const compellingStepsGroup = document.getElementById('compellingStepsGroup');

            if (strategy === 'partial') {
                compellingStepsGroup.style.display = 'block';
            } else {
                compellingStepsGroup.style.display = 'none';
            }
        }

        // é¡µé¢åŠ è½½æ—¶è¿æ¥ WebSocket
        window.onload = () => {
            connectWebSocket();

            // ç»‘å®šæ§åˆ¶ç­–ç•¥é€‰æ‹©å™¨äº‹ä»¶
            document.getElementById('controlStrategy').addEventListener('change', onControlStrategyChange);

            // åˆå§‹åŒ–æ˜¾ç¤ºçŠ¶æ€
            onControlStrategyChange();
        };

        // é¡µé¢å¸è½½æ—¶å…³é—­ WebSocket
        window.onbeforeunload = () => {
            if (ws) {
                ws.close();
            }
        };
    </script>
</body>
</html>
